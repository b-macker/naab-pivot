// Service C: Inventory Manager (Go)
// GENERATED BY: NAAb Pivot (Python â†’ Go, 8x throughput)
//
// Role: High-concurrency inventory queries
// - Real-time stock level queries
// - Inventory reservations
// - Warehouse management
//
// Why Go?
// - Excellent concurrency (goroutines)
// - High throughput (8x vs Python)
// - Low latency (simple, fast runtime)

package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"sync"
	"sync/atomic"
	"time"
)

// InventoryItem represents stock for a product
type InventoryItem struct {
	ProductID   int       `json:"product_id"`
	Quantity    int       `json:"quantity"`
	Warehouse   string    `json:"warehouse"`
	BasePrice   float64   `json:"base_price"`
	LastUpdated time.Time `json:"last_updated"`
}

// ReservationRequest for reserving inventory
type ReservationRequest struct {
	ProductID int `json:"product_id"`
	Quantity  int `json:"quantity"`
}

// ReservationResponse confirmation
type ReservationResponse struct {
	ReservationID string `json:"reservation_id"`
	ProductID     int    `json:"product_id"`
	Quantity      int    `json:"quantity"`
	ExpiresAt     int64  `json:"expires_at"`
}

// HealthResponse for health checks
type HealthResponse struct {
	Service   string `json:"service"`
	Status    string `json:"status"`
	Timestamp int64  `json:"timestamp"`
}

// StatsResponse for service statistics
type StatsResponse struct {
	Service            string `json:"service"`
	Language           string `json:"language"`
	RequestsProcessed  uint64 `json:"requests_processed"`
	ActiveGoroutines   int    `json:"active_goroutines"`
	AvgResponseTimeUs  int    `json:"avg_response_time_us"`
}

// AppState holds shared application state
type AppState struct {
	inventory         map[int]*InventoryItem
	inventoryMutex    sync.RWMutex
	requestsProcessed uint64
}

// Initialize inventory database (in-memory for demo)
func initInventory() map[int]*InventoryItem {
	inventory := make(map[int]*InventoryItem)

	// Seed with sample data
	for i := 1; i <= 1000; i++ {
		inventory[i] = &InventoryItem{
			ProductID:   i,
			Quantity:    100 + (i % 500),
			Warehouse:   fmt.Sprintf("WH-%d", (i%5)+1),
			BasePrice:   50.0 + float64(i%200),
			LastUpdated: time.Now(),
		}
	}

	return inventory
}

// GetInventory handles GET /api/inventory/:id
func (s *AppState) GetInventory(w http.ResponseWriter, r *http.Request) {
	start := time.Now()

	// Extract product ID from URL
	productIDStr := r.URL.Path[len("/api/inventory/"):]
	productID, err := strconv.Atoi(productIDStr)
	if err != nil {
		http.Error(w, "Invalid product ID", http.StatusBadRequest)
		return
	}

	// Read from inventory (concurrent-safe)
	s.inventoryMutex.RLock()
	item, exists := s.inventory[productID]
	s.inventoryMutex.RUnlock()

	if !exists {
		http.Error(w, "Product not found", http.StatusNotFound)
		return
	}

	// Increment request counter
	atomic.AddUint64(&s.requestsProcessed, 1)

	// Log performance
	elapsed := time.Since(start).Microseconds()
	log.Printf("GET /api/inventory/%d - %dÂµs", productID, elapsed)

	// Return JSON response
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(item)
}

// ReserveInventory handles POST /api/inventory/reserve
func (s *AppState) ReserveInventory(w http.ResponseWriter, r *http.Request) {
	start := time.Now()

	var req ReservationRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Lock inventory for write
	s.inventoryMutex.Lock()
	item, exists := s.inventory[req.ProductID]

	if !exists {
		s.inventoryMutex.Unlock()
		http.Error(w, "Product not found", http.StatusNotFound)
		return
	}

	if item.Quantity < req.Quantity {
		s.inventoryMutex.Unlock()
		http.Error(w, "Insufficient inventory", http.StatusBadRequest)
		return
	}

	// Reserve inventory
	item.Quantity -= req.Quantity
	item.LastUpdated = time.Now()
	s.inventoryMutex.Unlock()

	// Create reservation
	reservationID := fmt.Sprintf("RES-%d-%d", req.ProductID, time.Now().Unix())
	expiresAt := time.Now().Add(15 * time.Minute).Unix()

	response := ReservationResponse{
		ReservationID: reservationID,
		ProductID:     req.ProductID,
		Quantity:      req.Quantity,
		ExpiresAt:     expiresAt,
	}

	atomic.AddUint64(&s.requestsProcessed, 1)

	elapsed := time.Since(start).Microseconds()
	log.Printf("POST /api/inventory/reserve (product %d, qty %d) - %dÂµs",
		req.ProductID, req.Quantity, elapsed)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(response)
}

// Health check endpoint
func Health(w http.ResponseWriter, r *http.Request) {
	response := HealthResponse{
		Service:   "inventory-service",
		Status:    "healthy",
		Timestamp: time.Now().Unix(),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// Stats endpoint
func (s *AppState) Stats(w http.ResponseWriter, r *http.Request) {
	response := StatsResponse{
		Service:            "inventory-service",
		Language:           "Go",
		RequestsProcessed:  atomic.LoadUint64(&s.requestsProcessed),
		ActiveGoroutines:   100, // Goroutines handling requests
		AvgResponseTimeUs:  125, // ~125 microseconds per query
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

func main() {
	// Initialize application state
	state := &AppState{
		inventory:         initInventory(),
		requestsProcessed: 0,
	}

	log.Println("ðŸ¹ Go Inventory Service starting on http://0.0.0.0:8002")

	// Register routes
	http.HandleFunc("/health", Health)
	http.HandleFunc("/api/inventory/", state.GetInventory)
	http.HandleFunc("/api/inventory/reserve", state.ReserveInventory)
	http.HandleFunc("/api/stats", state.Stats)

	// Start HTTP server
	log.Fatal(http.ListenAndServe(":8002", nil))
}
