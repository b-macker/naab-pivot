// templates/rust_template.naab - Rust code generation template
// Variable substitution: ${FUNCTION_NAME}, ${ITERATIONS}, ${COMPLEXITY}
// Profile variables: ${OPT_LEVEL}, ${SIMD_FLAGS}, ${LTO}
// Compilation: rustc -C opt-level=${OPT_LEVEL} ${SIMD_FLAGS} -o vessel source.rs

use std::env;
use std::time::Instant;

// ${FUNCTION_NAME} - Auto-generated optimized function
// Complexity: ${COMPLEXITY}
// Iterations: ${ITERATIONS}
#[inline(always)]
fn ${FUNCTION_NAME}(val: f64) -> f64 {
    // Core computation with Rust safety guarantees
    let mut v = (val.powi(2) + 0.5).sqrt();

    // Main computation loop
    for _ in 0..${ITERATIONS} {
        v = (v + 0.01).sqrt();
        v *= 1.0001; // Prevent constant folding
    }

    v
}

// Parallel version using rayon (for ${COMPLEXITY} > 10)
#[cfg(feature = "parallel")]
fn ${FUNCTION_NAME}_parallel(val: f64, workers: usize) -> f64 {
    use rayon::prelude::*;

    if workers <= 1 {
        return ${FUNCTION_NAME}(val);
    }

    // Split work across threads
    let chunk_size = ${ITERATIONS} / workers;

    let results: Vec<f64> = (0..workers)
        .into_par_iter()
        .map(|w| {
            let start = w * chunk_size;
            let end = (w + 1) * chunk_size;
            let mut v = val;

            for _ in start..end {
                v = (v + 0.01).sqrt();
            }
            v
        })
        .collect();

    // Combine results
    results.iter().sum::<f64>() / workers as f64
}

// SIMD-optimized version (if ${SIMD_FLAGS} enabled)
#[cfg(all(target_arch = "x86_64", target_feature = "avx2"))]
#[inline(always)]
fn ${FUNCTION_NAME}_simd(val: f64) -> f64 {
    #[cfg(target_arch = "x86_64")]
    use std::arch::x86_64::*;

    unsafe {
        // Vectorized computation
        let mut v = _mm256_set1_pd(val);
        let increment = _mm256_set1_pd(0.01);

        for _ in 0..(${ITERATIONS} / 4) {
            v = _mm256_add_pd(v, increment);
            v = _mm256_sqrt_pd(v);
        }

        // Extract result
        let mut result = [0.0f64; 4];
        _mm256_storeu_pd(result.as_mut_ptr(), v);
        (result[0] + result[1] + result[2] + result[3]) / 4.0
    }
}

fn main() {
    let args: Vec<String> = env::args().collect();

    // Help mode
    if args.len() < 2 {
        println!("READY");
        println!("Function: ${FUNCTION_NAME}");
        println!("Complexity: ${COMPLEXITY}");
        println!("Optimization: ${OPT_LEVEL}");
        return;
    }

    // Parse input
    let input = match args[1].parse::<f64>() {
        Ok(val) => val,
        Err(e) => {
            eprintln!("Error: Invalid input: {}", e);
            std::process::exit(1);
        }
    };

    // Run computation
    let start = Instant::now();

    let result = if ${COMPLEXITY} > 15 {
        #[cfg(all(target_arch = "x86_64", target_feature = "avx2"))]
        {
            ${FUNCTION_NAME}_simd(input)
        }
        #[cfg(not(all(target_arch = "x86_64", target_feature = "avx2")))]
        {
            ${FUNCTION_NAME}(input)
        }
    } else if ${COMPLEXITY} > 10 {
        #[cfg(feature = "parallel")]
        {
            ${FUNCTION_NAME}_parallel(input, 4)
        }
        #[cfg(not(feature = "parallel"))]
        {
            ${FUNCTION_NAME}(input)
        }
    } else {
        ${FUNCTION_NAME}(input)
    };

    let elapsed = start.elapsed();

    // Output result with high precision
    println!("{:.15}", result);

    // Timing info to stderr
    if args.len() > 2 && args[2] == "--timing" {
        eprintln!("Time: {:.3}ms", elapsed.as_micros() as f64 / 1000.0);
    }
}
